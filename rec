#!/usr/bin/env bash

./deps rec2csv csvlook

if [[ -f $1 ]]; then
	input=$(cat "$1") && shift;
else
	[[ -t 0 ]] || input=$(cat);
fi

[[ -z $input ]] && input=$(cat .var/bare.rec)

command="$1" && shift

remaining_args=() && while [[ "$#" -gt 0 ]]; do
	case $1 in
		random|-m|--random) remaining_args+=(-m) && shift ;;
		--table) as_table=1 && shift ;;
		--as) as="$2" && shift 2 ;;
		*) remaining_args+=("$1") && shift ;;
	esac
done && set -- "${remaining_args[@]}"

case $command in

	schema) echo "$input" | recinf -d ;;

	tables|types) echo "$input" | recinf -d | sed -n '/^%rec/s/^%rec: //p' ;;

	select)

		echo "$input" | recsel "$@"

		;;

	list)

		case $1 in

			[dD]ocuments) echo "$input" | recsel -t Document -P Title -C | sed 's/$/  /' ;;

			[aA]ssistants) echo "$input" | recsel -t Assistant -P Name -C | sed 's/$/  /' ;;

			[sS]cripts) find .var/scripts -maxdepth 1 -print0 | xargs -0 -I {} basename {} | sed 's/$/  /' ;;

			[tT]hreads) ;;

		esac

		;;

	import)

		case $1 in

			from)

				shift

				file="$1" && shift
				[[ ! -f "$file" ]] && echo "ERROR: no such file: $1" && exit 1
				# if file is .csv file pipe to --from-csv, if .json pipe to --from-json
				destination="$2" && shift
				[[ $2 == 'to' ]] && destination="$3"
				[[ $file == *.csv ]] && rec --from-csv "$file" "$destination"
				[[ $file == *.json ]] && rec --from-json "$file" "$destination"

				;;

		esac

		;;

	--csv|--to-csv)

		echo "$input" | rec2csv

		;;

	--json|--to-json)

        # Convert recsel output to CSV, then to JSON, and format with jq
        json_output=$(echo "$input" | rec2csv 2>/dev/null | python3 -c 'import csv, json, sys; print(json.dumps([dict(r) for r in csv.DictReader(sys.stdin)]))' 2>/dev/null | jq 2>/dev/null)

        # Check if the conversion was successful
        if [[ $? -eq 0 ]]; then
            echo "$json_output" | jq
        else
            echo "Error: Conversion failed" >&2
            exit 1
        fi

		;;

	--from-json)
    
		[[ -f "$1" ]] && input="$(cat "$1")" && shift
		[[ -z $input ]] && echo "ERROR: no input provided" && exit 1
		# convert given input to csv
		output=$(echo "$input" | jq -r '(.[0] | keys_unsorted) as $keys | $keys, map([.[ $keys[] ]])[] | @csv' | csv2rec)
		[[ -n $1 ]] && echo "$output" >> "$1" || echo "$output"

        ;;

	--from-csv)

		[[ -f "$1" ]] && input="$(cat "$1")" && shift
		[[ -z $input ]] && echo "ERROR: no input provided" && exit 1
		output="$(echo "$input" | sed '1s/^\xEF\xBB\xBF//' | csv2rec)"
		[[ -n $1 ]] && echo "$output" >> "$1" || echo "$output"

		;;

esac

exit 0