#!/usr/bin/env bash

[ -z "$OPENAI_API_KEY" ] && {
	echo "OPENAI_API_KEY is not defined";
	exit 1;
}

./deps curl jq openssl

# capture assistant name
remaining_args=()

while [[ "$#" -gt 0 ]]; do
	case $1 in
		@*) assistant_name="${1#@}"; shift ;;
		--assistant) assistant_name="$2"; shift 2 ;;
		--thread) thread_name="$2"; shift 2 ;;
		*) remaining_args+=("$1"); shift ;;
	esac
done

# Reset positional parameters to remaining arguments
set -- "${remaining_args[@]}"

# set system prompt (according to assistant name)
assistant_prompt="You are a helpful assistant";
[[ -n $assistant_name ]] && {
	assistant_prompt="Your name is $assistant_name. $(./bare parse assistants | jq --arg name "$assistant_name" '.[] | select(.name == $name) | .contents' | ./bare codec json.decode)"
}

# Cycle through commands

case "$1" in 

    "chat" )

        shift
		# Initialize variables
		model=${OPENAI_DEFAULT_MODEL:-'gpt-3.5-turbo'}
		system_prompt="$assistant_prompt"
		user_messages=()
		assistant_messages=()
		
		# Read the first user message from arguments or stdin
		if [ -n "$1" ]; then
			user_messages+=("$1")
		else
			while IFS= read -r line; do
				user_messages+=("$line")
				break  # Exit after the first line of input
			done < /dev/stdin
		fi
		
		# Parse command-line arguments
		shift
		while [[ "$#" -gt 0 ]]; do
			case $1 in
				--model) model="$2"; shift 2 ;;
				--system_prompt) system_prompt="$2"; shift 2 ;;
				--user_messages) user_messages+=("$2"); shift 2 ;;
				--assistant_messages) assistant_messages+=("$2"); shift 2 ;;
				--messages) messages=$(echo "$2" | jq -c .); shift 2 ;;
				*) echo "Invalid option: $1" >&2 && exit 1 ;;
			esac
		done

		[[ -n $thread_name ]] && {
			thread_path=".var/threads/$(./bare codec text.filesafe "$thread_name").md";
			thread="$(./bare parse threads | jq --arg name "$thread_name" '.[] | select(.name == $name)')"
			[[ -z $thread ]] && {
				echo "---" >> "$thread_path"
				echo "name: $thread_name" >> "$thread_path"
				echo "created: $(date '+%Y-%m-%d %H:%M')" >> "$thread_path"
				echo "---" >> "$thread_path"
				thread="$(./bare parse threads | jq --arg name "$thread_name" '.[] | select(.name == $name)')"
			}
			echo "" >> "$thread_path"
			echo "USER: $user_messages" >> "$thread_path"
			echo "" >> "$thread_path"
			thread_contents="$(echo "$thread" | jq '.contents' | ./bare codec json.decode)"
			[[ $thread_contents != '' ]] && {
				user_messages="Given our thread here - - - $(./bare codec json.encode "$thread_contents") - - - and given I am the USER, - - - $user_messages"
			}
		}
		
		# Construct the messages array if not provided
		if [ -z "$messages" ]; then
			messages=$(jq -n --arg system_prompt "$system_prompt" '[
				{
					"role": "system",
					"content": $system_prompt
				}
			]')
		
			for i in "${!user_messages[@]}"; do
				messages=$(echo "$messages" | jq --arg content "${user_messages[$i]}" '. += [{"role": "user", "content": $content}]')
				if [ "$i" -lt ${#assistant_messages[@]} ]; then
					messages=$(echo "$messages" | jq --arg content "${assistant_messages[$i]}" '. += [{"role": "assistant", "content": $content}]')
				fi
			done
		fi
		
		# Construct the final JSON string using jq
		payload=$(jq -n --arg model "$model" --argjson messages "$messages" '{
			model: $model,
			messages: $messages
		}')
		
		response=$(./request "https://api.openai.com/v1/chat/completions" --token "$OPENAI_API_KEY" --json "$payload" | jq -r '.choices[0].message.content');

		[[ -n $thread_name ]] && {
			echo "" >> "$thread_path"
			echo "$(./bare uppercase "${assistant_name-Assistant}"): $response" >> "$thread_path"
			echo "" >> "$thread_path"
		}

		echo "$response"

        ;;


	"voice" )
		
		shift
		model='tts-1'
		voice='alloy'
		response_format='mp3'
		speed=1
	
		# Check if $1 is provided
		if [ -n "$1" ]; then
			input="$1"
		elif [ -t 0 ]; then  # Check if stdin is connected to a terminal
			echo "Error: No input provided. Please provide input as an argument or through stdin." >&2
			exit 1
		else
			read -r input
		fi

		output="$(./bare random string 32).mp3"

		while getopts "m:i:v:f:s:o:" opt; do
			case $opt in
				m ) model=$OPTARG ;;
				i ) input=$OPTARG ;;
				v ) voice=$OPTARG ;;
				f ) response_format=$OPTARG ;;
				s ) speed=$OPTARG ;;
				o ) output=$OPTARG ;;
				\? ) echo "Invalid option: $OPTARG" >&2 && exit 1 ;;
				: ) echo "Option -$OPTARG requires an argument." >&2 && exit 1 ;;
			esac
		done

		curl -s https://api.openai.com/v1/audio/speech \
			-H "Authorization: Bearer $OPENAI_API_KEY" \
			-H "Content-Type: application/json" \
			-d '{
				"model": "'"$model"'",
				"input": "'"$input"'",
				"voice": "'"$voice"'",
				"response_format": "'"$response_format"'",
				"speed": "'"$speed"'"
			}' \
			--output ".var/downloads/$output"

		# Check if the file was created and is not empty
		if [ ! -s ".var/downloads/$output" ]; then
			echo "Error: File $output was not created or is empty" >&2
			exit 1
		fi

		echo ".var/downloads/$output"

		;;
	"listen" )

		# Coming soon. OpenAI only accepts text and image as of now.

		;;


	"transcribe" )

		shift
		model='whisper-1'
		language='en'
		prompt=''
		response_format='json'
		temperature=0
		timestamp_granularities='segment'
		file="$1" && shift

		while [[ "$#" -gt 0 ]]; do
			case $1 in
				--model) model="$2"; shift ;;
				--language) language="$2"; shift ;;
				--prompt) prompt="$2"; shift ;;
				--response_format) response_format="$2"; shift ;;
				--temperature) temperature="$2"; shift ;;
				--timestamp_granularities) timestamp_granularities="$2"; shift ;;
				*) echo "Invalid option: $1" >&2 && exit 1 ;;
			esac
			shift
		done

		if [ -z "$file" ]; then
			read -r file
			if [ -z "$file" ]; then
				echo "Error: No file path provided" >&2
				exit 1
			fi
		fi
		
		if [ ! -f "$file" ]; then
			echo "Error: File '$file' not found" >&2
			exit 1
		fi

		# Check if the file size is greater than 20MB (20 * 1024 * 1024 bytes)
		file_size=$(stat -f%z "$file")
		max_size=$((20 * 1024 * 1024))
		if [ "$file_size" -gt "$max_size" ]; then
			echo "Warning: Files larger than 20MB are not supported. The transcription may fail." >&2
			# Optionally, exit or continue based on your requirements
			# exit 1
		fi
		
		response=$(curl -s https://api.openai.com/v1/audio/transcriptions \
			-H "Authorization: Bearer $OPENAI_API_KEY" \
			-H "Content-Type: multipart/form-data" \
			-F file="@$file" \
			-F model="$model" \
			-F language="$language" \
			-F prompt="$prompt" \
			-F response_format="$response_format" \
			-F temperature="$temperature" \
			-F timestamp_granularities="$timestamp_granularities")
		
		# Extract the text property from the JSON response and print it
		echo "$response" | jq -r '.text'
		;;

	* )
		echo "Invalid argument"
		exit 1
		;;
esac