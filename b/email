#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

# ================================== DOC ===================================
declare doc_name="email"
declare doc_description="Send and receive email with SMTP/POP3 and Postmark"
declare -a doc_options=(
	"send"		"Send email"
	"check"		"Check email"
) && [[ "$1" == '--inspect' ]] && return 0
# ==========================================================================

command="$1"
shift

case "$command" in


    # ========================================
    send ) # send email

		doc_name+=" send"
		doc_description="Send email"
		declare -a doc_options=(
			"-t"		"* To"
			"-f"		"* From"
			"-c"		"  Cc"
			"-b"		"  Bcc"
			"-s"		"* Subject"
			"-h"		"* HTML Body"
			"-a"		"  Attachment"
			"-H"		"* Host SMTP Server"
			"-P"		"  Port"
			"-p"		"= Password"
		) && [[ "$1" == '--inspect' ]] && return 0

        [[ -z "$1" ]] && b/usage -w 8 "$0" \
            -f "* From" \
            -t "* To" \
            -c "  Cc" \
            -b "  Bcc" \
            -s "* Subject" \
            -h "* HTML Body" \
            -a "  Attachment" \
            -H "* Host SMTP Server" \
            -P "  Port" \
            -p "= Password" && exit 0;

        to=""
        from=""
        cc=""
        bcc=""
        subject=""
        html_body=""
        attachment=""

        server=""
        port="465"

        password=""

        # getopts
        while getopts "t:f:c:b:s:h:a:p:H:P:" opt; do
            case $opt in
                t ) to="$OPTARG" ;;
                f ) from="$OPTARG" ;;
                c ) cc="$OPTARG" ;;
                b ) bcc="$OPTARG" ;;
                s ) subject="$OPTARG" ;;
                h ) html_body="$OPTARG" ;;
                a ) IFS=',' read -r -a attachments <<< "$OPTARG" ;;
                p ) password="$OPTARG" ;;
                H ) server="$OPTARG" ;;
                P ) port="$OPTARG" ;;
                \? ) echo "Invalid option -$OPTARG" >&2; exit 1 ;;
            esac
        done

        # if p not provided, read -s
        if [ -z "$password" ]; then
          read -rs -p "Password: " password
        fi

        tmp_file="./tmp/$(openssl rand -hex 12).txt"

        # Define a unique boundary string
        boundary="=====$(date +%s)====="

        # Create a temporary file for the email headers and body
        cat <<EOF > "$tmp_file"
From: $from
To: $to
Cc: $cc
Bcc: $bcc
Subject: $subject
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="$boundary"

--$boundary
Content-Type: text/html; charset=utf-8
Content-Transfer-Encoding: quoted-printable

$html_body
EOF

        # Loop through each attachment and add it to the email
        for attachment in "${attachments[@]}"; do
            if [ -n "$attachment" ] && [ -r "$attachment" ]; then
                echo "--$boundary" >> "$tmp_file"
                echo "Content-Type: application/octet-stream; name=\"$(basename "$attachment")\"" >> "$tmp_file"
                echo "Content-Transfer-Encoding: base64" >> "$tmp_file"
                echo "Content-Disposition: attachment; filename=\"$(basename "$attachment")\"" >> "$tmp_file"
                echo "" >> "$tmp_file"

                # Determine whether to use gbase64 (macOS with coreutils) or base64 (other systems)
                base64_cmd="base64"
                if [[ "$OSTYPE" == "darwin"* ]] && command -v gbase64 >/dev/null 2>&1; then
                    base64_cmd="gbase64"
                fi

                # Use the determined base64 command to encode the attachment
                if ! $base64_cmd -w 0 "$attachment" >> "$tmp_file"; then
                    echo "Error: Failed to encode attachment" >&2
                    exit 1
                fi
                echo "" >> "$tmp_file"
                # Do not close the boundary here
            else
                echo "Warning: Attachment file '$attachment' does not exist or is not readable" >&2
            fi
        done

        # Close the MIME multipart message after all attachments have been added
        echo "--$boundary--" >> "$tmp_file"

        curl -s -n --ssl-reqd --url "smtps://$server:$port" --mail-from "$from" --mail-rcpt "$to" --user "$from:$password" --upload-file "$tmp_file"


        # remove the tmp file
        rm "$tmp_file"
        
        ;;

    # ========================================
    check ) # check email

		doc_name+=" check"
		doc_description="Check email"
		declare -a doc_options=(
			"-l"		"List messages"
			"-m"		"Message number"
			"-H"		"Host POP3 Server"
			"-P"		"Port"
			"-u"		"= Username"
			"-p"		"= Password"
		) && [[ "$1" == '--inspect' ]] && return 0

        server=""
        port="995"
        username=""
        password=""

        # getopts
        while getopts "lm:H:P:u:p:" opt; do
            case $opt in
                l ) list="$OPTARG" ;;
                m ) message="$OPTARG" ;;
                H ) server="$OPTARG" ;;
                P ) port="$OPTARG" ;;
                u ) username="$OPTARG" ;;
                p ) password="$OPTARG" ;;
                \? ) echo "Invalid option -$OPTARG" >&2; exit 1 ;;
            esac
        done

        # if p not provided, read -s
        if [ -z "$password" ]; then
          read -rs -p "Password: " password
        fi

        # check pop3 with curl
        if [[ -n "$list" ]]; then
            curl -s -n --ssl-reqd "pop3s://$server:$port" --user "$username:$password"
        else
            curl -s -n --ssl-reqd "pop3s://$server:$port/$message" --user "$username:$password"
        fi

        ;;
esac
