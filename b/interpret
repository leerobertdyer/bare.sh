#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

doc="$(cat <<'EOF'

# interpret

Interpret scripts and commands

`[-I]`			| Start an interactive session
`[:command]`	| Runs a given script by name (scripts located in $BARE_DIR/var/.nb/scripts)

> interpret -I				| Start an interactive session
> interpret weather.bare	| Run a the weather script

EOF
)" && inspect "$doc" "$1"
# =============================================================================



process_line() {
	# Check if the line starts with 'set'
	if [[ ${words[0]} == "set" ]]; then
		# Get the name of the variable to set
		var_name=${words[1]}
		# Validate the variable name
		if [[ ! $var_name =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
			echo "Error: Invalid variable name '$var_name'"
			return 1
		fi
		# Capture everything after 'set var_name =' into the variable
		command_output=$(./bare "${words[@]:3}" 2>/dev/null)
		# Check the exit status of the command
		if [[ $? -ne 0 ]]; then
			echo "Error: Command failed"
			return 1
		fi
		export "$var_name=$command_output"
	else
		# Replace placeholders with variable values
		for i in "${!words[@]}"; do
			if [[ ${words[i]} =~ \$\((.*)\) ]]; then
				# Detect command substitution
				command=${BASH_REMATCH[1]}
				# Replace the command substitution with the output of the 'bare' command
				words[i]=$(./bare "$command" 2>/dev/null)
			fi
		done
		# Execute the command
		response=$(./bare "${words[@]}" 2>/dev/null)
		# Check the exit status of the command
		if [[ $? -eq 0 ]]; then
			echo "$response"
		fi
	fi
	return 0
}

# Check if the first argument is -I
if [[ $1 == "-I" ]]; then
	while true; do
		echo -n "> "
		read -r line
		[[ $line == "exit" || $line == ".q" ]] && break
		eval "words=($line)"
		process_line "${words[@]}"
	done
	exit 0
fi

# if we're this far, we're about to run a script. Check if additional positional arguments were passed
script_name=$1 && shift
additional_args=("$@")

# Construct the full path to the file
file_path="$BARE_DIR/var/.nb/scripts/$script_name"

# Check if the file exists and is in the var/.nb/scripts directory
if [[ -f $file_path ]]; then
	# Read the file line by line
	while IFS= read -r line || [[ -n $line ]]; do
		[[ $line = \#* ]] && continue
		eval "words=($line)"
		# Check if the line starts with a word ending in a colon
		if [[ ${words[0]} =~ ^.*:$ ]]; then
			# Get the name of the variable to set
			var_name=${words[0]%:}
			# Validate the variable name
			if [[ ! $var_name =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
				echo "Error: Invalid variable name '$var_name'"
				continue
			fi
			# Capture everything after the colon into the variable
			command_output=$(./bare "${words[@]:1}" "${additional_args[@]}")
			# Check the exit status of the command
			if [[ $? -ne 0 ]]; then
				echo "Error: Command failed"
				continue
			fi
			export "$var_name=$command_output"
		else
			if [[ ${#words[@]} -gt 0 ]]; then
				./bare "${words[@]}"
				# Check the exit status of the command
				if [[ $? -ne 0 ]]; then
					echo "Error: Command failed"
					continue
				fi
			fi
		fi
	done < "$file_path"
else
	echo "Error: $1 is not a file or is not in the "$BARE_DIR"/var/.nb/scripts directory"
fi

exit 0