#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

doc="$(cat <<'EOF'

# interpret

Interpret scripts and commands

`[-I]`			| Start an interactive session
`[:command]`	| Runs a given script by name (scripts located in $BARE_DIR/var/.nb/scripts)

> interpret -I				| Start an interactive session
> interpret weather.bare	| Run a the weather script

EOF
)" && inspect "$doc" "$1"
# =============================================================================


process_line() {
	# Replace placeholders with variable values
	for i in "${!words[@]}"; do
		if [[ ${words[i]} == "-I" ]]; then
			continue
		elif [[ ${words[i]} =~ \$([a-zA-Z_][a-zA-Z0-9_]*) ]]; then
			var_name=${BASH_REMATCH[1]}
			if [[ -n ${!var_name} ]]; then
				# Base64 decode the value
				words[i]=$(./bare codec base64.decode "${!var_name}")
			else
				echo "Error: Undefined variable '$var_name'"
				return 1
			fi
		elif [[ ${words[i]} =~ \$\((.*)\) ]]; then
			# Detect command substitution
			command=${BASH_REMATCH[1]}
			# Replace the command substitution with the output of the 'bare' command
			words[i]=$(./bare $command 2>/dev/null)
			# Check the exit status of the command
			if [[ $? -ne 0 ]]; then
				echo "Error: Command failed"
				return 1
			fi
		fi
	done

	# Execute the command
	(./bare "${words[@]}" 2>/dev/null)

	# Check the exit status of the command
	if [[ $? -ne 0 ]]; then
		echo "Error: Command failed"
		return 1
	fi

	# Source the temporary file
	source "$HOME/.bare_variables"
}

# Check if the first argument is -I
if [[ $1 == "-I" ]]; then
	while true; do
		echo -n "> "
		read -r line
		[[ $line == "exit" || $line == ".q" ]] && break
		if [[ $line =~ ^\$([a-zA-Z_][a-zA-Z0-9_]*)$ ]]; then
			# If the line is a variable, decode its value before printing
			var_name=${BASH_REMATCH[1]}
			if [[ -n ${!var_name} ]]; then
				# Base64 decode the value
				echo $(./bare codec base64.decode "${!var_name}")
			else
				echo "Error: Undefined variable '$var_name'"
			fi
		else
			eval "words=($line)"
			process_line "${words[@]}"
		fi
	done
	exit 0
fi

# Main loop
for line in "$@"; do
	# Split the line into words
	IFS=' ' read -r -a words <<< "$line"
	# Check if the command is valid
	if type "${words[0]}" > /dev/null 2>&1; then
		# If the command is valid, process the line
		process_line
	fi
done

# Check if the first argument is a valid b/* script
if [[ -f "b/$1" && -x "b/$1" ]]; then
	# Execute the script and capture its output
	command_output=$(./bare "$1" "${@:2}" 2>/dev/null)
	# Check the exit status of the script
	if [[ $? -ne 0 ]]; then
		echo "Error: Script failed"
		exit 1
	fi
	[[ -n $command_output ]] && echo "$command_output"
	exit 0
fi


# Construct the full path to the file
file_path="$BARE_DIR/var/.nb/scripts/$1"

# Check if the file exists and is in the var/.nb/scripts directory
if [[ -f $file_path ]]; then
	# Read the file line by line
	while IFS= read -r line || [[ -n $line ]]; do
		[[ $line = \#* ]] && continue
		if [[ $line =~ ^\$([a-zA-Z_][a-zA-Z0-9_]*)$ ]]; then
			# If the line is a variable, decode its value before using
			var_name=${BASH_REMATCH[1]}
			if [[ -n ${!var_name} ]]; then
				# Base64 decode the value
				line=$(echo "${!var_name}" | base64 --decode)
			else
				echo "Error: Undefined variable '$var_name'"
				continue
			fi
		fi
		eval "words=($line)"
		process_line "${words[@]}"
	done < "$file_path"
	exit 0
fi

exit 0