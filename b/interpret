#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

touch "$BARE_DIR/tmp/variables"
touch "$BARE_HOME/.nb/scripts/sandbox.bare"

process_line() {
	source "$BARE_DIR/tmp/variables" 2>/dev/null
	source "$BARE_HOME/rc" 2>/dev/null
	# Use eval to split the line into words
	eval "words=($line)"
	# Replace placeholders with variable values
	for i in "${!words[@]}"; do
		# Remove quotes from the argument
		words[i]=${words[i]//\"/}
		if [[ ${words[i]} =~ \$\((.*)\) ]]; then
			# Detect command substitution
			command=${BASH_REMATCH[1]}
			# Replace the command substitution with the output of the 'bare' command
			words[i]=$(./bare "$command" 2>/dev/null)
		elif [[ ${words[i]} =~ \$([a-zA-Z_][a-zA-Z0-9_]*) ]]; then
			var_name=${BASH_REMATCH[1]}
			if [[ -n ${!var_name} ]]; then
				words[i]=${!var_name}
			else
				echo "Error: Undefined variable '$var_name'"
				return 1
			fi
		fi
	done

	# Check for AND keyword and split the command if found
	and_indices=()
	for i in "${!words[@]}"; do
		if [[ ${words[i]} == "AND" ]]; then
			and_indices+=($i)
		fi
	done

	# If AND keywords were found, split the command and execute each part sequentially
	if [[ ${#and_indices[@]} -ne 0 ]]; then
		start_index=0
		for and_index in "${and_indices[@]}"; do
			command_part=("${words[@]:$start_index:$and_index-$start_index}")
			# Check for INTO keyword and split the command if found
			into_index=-1
			for i in "${!command_part[@]}"; do
				if [[ ${command_part[i]} == "INTO" ]]; then
					into_index=$i
					break
				fi
			done
			if [[ $into_index -ne -1 ]]; then
				# Split the command_part array into two commands
				command1=("${command_part[@]:0:into_index}")
				command2=("${command_part[@]:into_index+2}")
				# Execute the first command
				response=$(./bare "${command1[@]}" 2>/dev/null)
				# Check the exit status of the command
				if [[ $? -ne 0 ]]; then
					return 1
				fi
				# Use the output of the first command as the argument for the second command
				command2=("INTO" "$response" "${command2[@]}")
				response=$(./bare "${command2[@]}" 2>/dev/null)
			else
				# Execute the command
				response=$(./bare "${command_part[@]}" 2>/dev/null)
			fi
			# Check the exit status of the command
			if [[ $? -eq 0 ]]; then
				echo "$response"
			fi
			start_index=$((and_index + 1))
		done
		# Execute the last part of the command
		command_part=("${words[@]:$start_index}")
		response=$(./bare "${command_part[@]}" 2>/dev/null)
	else
		# Execute the command
		response=$(./bare "${words[@]}" 2>/dev/null)
	fi

	# Check the exit status of the command
	if [[ $? -eq 0 ]]; then
		echo "$response"
	fi
	return 0
}

# Check if the first argument is -I or -i
if [[ $1 == "-I" || $1 == "-i" ]]; then
	if [[ $1 == "-I" ]]; then
		while true; do
			echo -n "> "
			read -r line
			[[ $line == "exit" || $line == ".q" ]] && break
			read -a words <<< "$line"
			process_line "${words[@]}"
		done
	else
		shift
		words=("$@")
		process_line "${words[@]}"
	fi
	# clear up any temporary variables
	if [[ -e "$BARE_DIR/tmp/variables" ]]; then
		rm "$BARE_DIR/tmp/variables"
	fi
	exit 0
fi

# if we're this far, we're about to run a script. Check if additional positional arguments were passed
script_name=$1 && shift
additional_args=("$@")

# Construct the full path to the file
file_path="$BARE_HOME/.nb/scripts/$script_name"

# Check if the file exists and is in the var/.nb/scripts directory
if [[ -f $file_path ]]; then
	# Read the file line by line
	while IFS= read -r line || [[ -n $line ]]; do
		[[ $line = \#* ]] && continue
		eval "words=($line)"
		process_line "${words[@]}"
	done < "$file_path"
else
	echo "Error: $1 is not a file or is not in the "$BARE_HOME"/.nb/scripts directory"
fi



# clear up any temporary variables
if [[ -e "$BARE_DIR/tmp/variables" ]]; then
	rm "$BARE_DIR/tmp/variables"
fi
