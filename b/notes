#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

doc="$(cat <<'EOF'

# notes

Manage notes with nb

`notebooks.create`	| Create a new notebook
`notebooks.list`	| List notebooks
`list`				| List notes
`show`				| Show a note
`create`			| Create a new note
`edit`				| Edit a note
`delete`			| Delete a note

> notes list										| List notes
> notes show 1										| Show a note its ID
> notes show scripts:weather.bare					| Show a note by its notebook:filename
> notes create -T "My note" -C "This is my note"	| Create a new note

EOF
)" && inspect "$doc" "$1"
# =============================================================================



command="$1"
shift

nb use home > /dev/null

# make sure nb home notebook is present
[[ ! -d $BARE_NOTES_DIR/home ]] && nb notebooks add home > /dev/null 2>&1

# make sure we've initialized the notes
[[ ! -d $BARE_NOTES_DIR ]] && nb init > /dev/null 2>&1

case $command in

	notebooks.create )

		nb notebooks add "$1"
		;;

	notebooks.list )
		nb notebooks --no-color
		;;

	notebook.rename )
		nb notebooks rename "$1" "$2" --no-color
		;;

	notebook.delete )
		# make sure the notebook exists
		nb notebooks delete "$1" --force --no-color
		;;

    list ) doc="$(cat <<'EOF'

# notes list

List notes

`-l`	| Limit the number of notes to display
`-t`	| Filter by note type
`-r`	| Reverse the order of the notes
`-i`	| IDs only
`-n`	| Names only
`-J`	| Output as JSON
`-N`	| Notebook to list notes from

> notes list -l 5			| List the last 5 notes
> notes list -t todo		| List notes with the 'todo' type
> notes list -r				| List notes in reverse order
> notes list research: -J	| List notes in the 'research' notebook as JSON

EOF
		)" && inspect "$doc" "$1"
		# ======================

		declare -a args=()
		args+=("--no-color" "--no-indicator")
		names_only=false
		ids_only=false
		while getopts "l:t:riTnJN:" opt; do
			case $opt in
				l ) args+=("--limit" "$OPTARG") ;;
				t ) args+=("--type" "$OPTARG") ;;
				r ) args+=("--reverse") ;;
				i ) ids_only=true && shift ;;
				T ) titles=true && shift ;;
				n ) names_only=true && shift ;;
				J ) as_json=true && shift ;;
				N ) notebook=$OPTARG ;;
				\? )
					echo "Invalid option: -$OPTARG" 1>&2
					exit 1
					;;
			esac
		done

		if [[ -z "$titles" ]]; then
			args+=("--filenames")
		fi

		notebook=${notebook:-"home"}
		args+=("$notebook:")

		list=$(nb list "${args[@]}")

		if [[ $names_only == true ]]; then
			list="$(echo "$list" | awk '{print substr($0, index($0,$2))}')"
		fi

		# Check if the list contains any lines that look like list items
		if ! echo "$list" | grep -q '^\[.*\]'; then
			list=""
		fi

		if [[ $ids_only == true ]]; then
			echo "$list" | awk -F'[][]' '{print $2}'
		elif [[ $as_json == true ]]; then
			if [[ -z "$list" ]]; then
				echo '[]'
			else
				echo "$list" | awk -F'[][]' '{sub(/^ /, "", $3); split($2, a, ":"); print "{\"notebook\": \"" (length(a) > 1 ? a[1] : "home") "\", \"id\": " (length(a) > 1 ? a[2] : a[1]) ", \"filename\": \"" $3 "\"}"}' | jq -R -s -c 'split("\n")[:-1] | map(fromjson)'
			fi
		else
			echo "$list"
		fi

		;;

    show )

		id="$1" && shift
		if [[ "$1" == "--title" ]]; then
			nb list "$1" --no-color --no-indicator | awk '{print substr($0, index($0,$2))}'
		else
			nb show "$id" --print
		fi

		;;

    create ) doc="$(cat <<'EOF'

# notes create

Create a new note

`-T`		| Title of the note
`-C`		| Content of the note
`-t`		| Comma-separated tags for the note (my-tag,tag2,another-tag)
`-E`		| Encrypt the note
`-P`		| Password for the note
`-N`		| Notebook to save the note in (defaults to 'home')
`-F`		| Folder to save the note in
`-f`		| Filename for the note

> notes create -T "My note" -C "This is my note"								| Create a new note
> notes create -T "My note" -C "This is my note" -t "my-tag,tag2,another-tag"	| Create a new note with tags

EOF
		)" && inspect "$doc" "$1"
		# ======================

        notebook="home"
		title="$1"
        declare -a content=()
        while getopts "T:C:t:EP:N:F:f:" opt; do
            case $opt in
                T ) title=$OPTARG ;;
                C ) content+=("$OPTARG") ;;
                t ) tags=$OPTARG ;;
                E ) encrypt=$OPTARG ;;
                P ) password=$OPTARG ;;
                N ) notebook=$OPTARG ;;
                F ) folder=$OPTARG ;;
                f ) filename=$OPTARG ;;
                \? )
                    echo "Invalid option: -$OPTARG" 1>&2
                    exit 1
                    ;;
                : )
                    echo "Option -$OPTARG requires an argument." 1>&2
                    exit 1
                    ;;
            esac
        done

        # if -E is set, -P must also be set
        [ -n "$encrypt" ] && [ -z "$password" ] && echo "Error: Encryption flag (-E) requires a password (-P)" && exit 1

        declare -a args=("$notebook:add" "--no-color")
        [ -n "$title" ] && args+=("--title" "$title")
		for item in "${content[@]}"; do args+=("--content" "$item"); done
        [ -n "$tags" ] && args+=("--tags" "$tags")
        [ -n "$password" ] && args+=("-e" "--password" "$password")
        [ -n "$folder" ] && args+=("--folder" "$folder")
        [ -n "$filename" ] && args+=("--filename" "$filename")

		[[ -z "${content[0]}" ]] && output=$(echo "" | nb "${args[@]}")
		[[ -n "$content" ]] && output=$(nb "${args[@]}")

		id=$(echo "$output" | awk -F'[][]' '{print $2}') && echo "$id"
        ;;

	open )

		id="$1" && shift
		notebook="home"
		while getopts "N:" opt; do
			case $opt in
				N ) notebook=$OPTARG ;;
				* ) echo "Invalid option: -$OPTARG" 1>&2; exit 1 ;;
			esac
		done

		nb use "$notebook" > /dev/null
		nb edit "$id" --edit

		;;

    edit ) doc="$(cat <<'EOF'

# notes edit

Edit a note

`-n`	| ID of the note
`-T`	| Title of the note
`-C`	| Content of the note
`-E`	| Encrypt the note
`-P`	| Password for the note
`-N`	| Notebook to save the note in (defaults to 'home')
`-F`	| Folder to save the note in
`-f`	| Filename for the note

> notes edit -n 1 -T "My note" -C "This is my note"	| Edit a note

EOF
		)" && inspect "$doc" "$1"
		# ======================

		id="$1" && shift
        notebook="home"
        declare -a content=()
		append=false
        while getopts "T:C:EP:N:F:f:a" opt; do
            case $opt in
                T ) title=$OPTARG ;;
                C ) content+=("$OPTARG") ;;
                E ) encrypt=$OPTARG ;;
                P ) password=$OPTARG ;;
                N ) notebook=$OPTARG ;;
                F ) folder=$OPTARG ;;
                f ) filename=$OPTARG ;;
				a ) append=true ;;
				* ) echo "Invalid option: -$OPTARG" 1>&2; exit 1 ;;
            esac
        done

		[ -z "$id" ] && echo "Error: Must provide an ID (-n)" && exit 1
		[ -n "$encrypt" ] && [ -z "$password" ] && echo "Error: Encryption flag (-E) requires a password (-P)" && exit 1

		nb use "$notebook" > /dev/null
		declare -a args=("edit" "$id" "--no-color")

		[[ "$append" = false ]] && {
			[[ -z "$title" ]] && title=$(nb show "$id" --print | head -n 1)
			[[ -n "$title" ]] && args+=("--content" "# $title")
		}
		[[ "$append" = false ]] && args+=("--overwrite")
		[ -n "$notebook" ] && args+=("--notebook" "$notebook")
		[ -n "$folder" ] && args+=("--folder" "$folder")
		[ -n "$filename" ] && args+=("--filename" "$filename")
		for item in "${content[@]}"; do args+=("--content" "$item"); done
        [ -n "$password" ] && args+=("-e" "--password" "$password")

		nb "${args[@]}" > /dev/null

        ;;

    delete )

        file="$1"
        nb delete "$file" --force --no-color > /dev/null
        ;;

    * ) echo "Invalid command: $command" && exit 1 ;;
	
esac