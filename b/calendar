#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

# Function to remove empty lines from the output
remove_empty_lines() {
	echo "$1" | awk 'NF > 0'
}

get_month_number() {
	local month="$1"
	case "$month" in
		"january") echo 1 ;;
		"february") echo 2 ;;
		"march") echo 3 ;;
		"april") echo 4 ;;
		"may") echo 5 ;;
		"june") echo 6 ;;
		"july") echo 7 ;;
		"august") echo 8 ;;
		"september") echo 9 ;;
		"october") echo 10 ;;
		"november") echo 11 ;;
		"december") echo 12 ;;
		*) echo "Invalid month" ;;
	esac
}

generate_specific_month() {
	local months_to_target="$1"
	local direction="$2"
	if [[ "$OSTYPE" == "darwin"* ]]; then
		# macOS uses BSD date
		if [ "$direction" = "ahead" ]; then
			cal $(date -v +"$months_to_target"m +%m) $(date -v +"$months_to_target"m +%Y)
		elif [ "$direction" = "behind" ]; then
			cal $(date -v -"$months_to_target"m +%m) $(date -v -"$months_to_target"m +%Y)
		fi
	else
		# Assume GNU date
		if [ "$direction" = "ahead" ]; then
			cal $(date -d "+${months_to_target} month" +%m) $(date -d "+${months_to_target} month" +%Y)
		elif [ "$direction" = "behind" ]; then
			cal $(date -d "-${months_to_target} month" +%m) $(date -d "-${months_to_target} month" +%Y)
		fi
	fi
}

adjust_months() {
	local base_months="$1"
	local adjustment="$2"
	local total_months

	if [[ "$adjustment" =~ ^(\+|\-)[0-9]+$ ]]; then
		total_months=$((base_months + adjustment))
	elif [[ "$adjustment" =~ ^[0-9]+$ ]]; then
		total_months=$((base_months + adjustment))
	else
		total_months=$base_months
	fi

	echo "$total_months"
}

# Handle direct modifiers like '+ N' or '- N'
if [[ "$1" =~ ^(\+|\-)$ ]]; then
	adjustment="${1}${2// /}" # Combine + or - with the number, remove spaces

	if (( adjustment < 0 )); then
		direction="behind"
		adjustment=${adjustment#-} # Remove the negative sign
	else
		direction="ahead"
	fi

	months_to_target=$(adjust_months 0 "$adjustment")

	result=$(generate_specific_month "$months_to_target" "$direction")
	clean_result=$(remove_empty_lines "$result")
	echo "$clean_result"
	exit 0
fi

generate_calendar() {
	local months="$1"
	local direction="$2"
	for ((i=0; i<$months; i++)); do
		if [[ "$OSTYPE" == "darwin"* ]]; then
			# macOS uses BSD date
			if [ "$direction" = "ahead" ]; then
				cal $(date -v +${i}m +%m) $(date -v +${i}m +%Y)
			else
				cal $(date -v -${i}m +%m) $(date -v -${i}m +%Y)
			fi
		else
			# Assume GNU date
			if [ "$direction" = "ahead" ]; then
				cal $(date -d "+${i} month" +%m) $(date -d "+${i} month" +%Y)
			else
				cal $(date -d "-${i} month" +%m) $(date -d "-${i} month" +%Y)
			fi
		fi
	done
}

# Using bash, when given no arguments, simply print the current month (using `cal`)
if [ $# -eq 0 ]; then
	today=$(date +%e)
	result=$(cal)
	remove_empty_lines "$result"
	exit 0
fi

# When given 'for 3', print the current month and the next 2 months
if [ "$1" = "for" ]; then
	if [[ "$2" =~ ^[0-9]+$ ]]; then
		months=$2
	else
		months=1
	fi
	result=$(generate_calendar "$months" "ahead")
	remove_empty_lines "$result"
	exit 0
fi

# When given 'ahead 3' or 'ahead for 3', print the next 3 months (or 4 if given '4')
if [ "$1" = "ahead" ] && [ "$2" != "by" ]; then
	if [[ "$2" =~ ^[0-9]+$ ]]; then
		months=$2
	else
		months=${3:-1}
	fi
	result=$(generate_calendar "$months" "ahead")
	remove_empty_lines "$result"
	exit 0
fi

# When given 'behind 3' or 'behind for 3', print the previous 3 months (or 4 if given '4')
if [ "$1" = "behind" ] && [ "$2" != "by" ]; then
	if [[ "$2" =~ ^[0-9]+$ ]]; then
		months=$2
	else
		months=${3:-1}
	fi
	result=$(generate_calendar "$months" "behind")
	remove_empty_lines "$result"
	exit 0
fi

# Handle 'this past'
if [ "$1" = "this" ] && [ "$2" = "past" ]; then
	# Convert the input month to lowercase
	lowercase_month=$(echo "$3" | tr '[:upper:]' '[:lower:]')
	# Get the month number
	target_month=$(get_month_number "$lowercase_month")
	current_month=$(date +%m)
	# Calculate the offset
	if (( target_month >= current_month )); then
		months_to_target=$((12 + current_month - target_month))
	else
		months_to_target=$((current_month - target_month))
	fi

	# Check for additional modifier
	if [ -n "$4" ] && [[ "$4" =~ ^(\+|\-)$ ]]; then
		adjustment="${4}${5// /}" # Combine + or - with the number, remove spaces
		months_to_target=$(adjust_months "$months_to_target" "$adjustment")
	fi

	result=$(generate_specific_month "$months_to_target" "behind")
	clean_result=$(remove_empty_lines "$result")
	echo "$clean_result"
	exit 0
fi

# Handle 'this coming'
if [ "$1" = "this" ] && [ "$2" = "coming" ]; then
	# Convert the input month to lowercase
	lowercase_month=$(echo "$3" | tr '[:upper:]' '[:lower:]')
	# Get the month number
	target_month=$(get_month_number "$lowercase_month")
	current_month=$(date +%m)
	# Calculate the offset
	if (( target_month > current_month )); then
		months_to_target=$((target_month - current_month))
	else
		months_to_target=$((12 + target_month - current_month))
	fi

	# Check for additional modifier
	if [ -n "$4" ] && [[ "$4" =~ ^(\+|\-)$ ]]; then
		adjustment="${4}${5// /}" # Combine + or - with the number, remove spaces
		months_to_target=$(adjust_months "$months_to_target" "$adjustment")
	fi

	result=$(generate_specific_month "$months_to_target" "ahead")
	clean_result=$(remove_empty_lines "$result")
	echo "$clean_result"
	exit 0
fi

# Handle direct modifiers like '+ N' or '- N'
if [[ "$1" =~ ^(\+|\-)$ ]]; then
	adjustment="${1}${2// /}" # Combine + or - with the number, remove spaces

	if (( adjustment < 0 )); then
		direction="behind"
	else
		direction="ahead"
	fi

	months_to_target=$(adjust_months 0 "$adjustment")

	result=$(generate_specific_month "$months_to_target" "$direction")
	clean_result=$(remove_empty_lines "$result")
	echo "$clean_result"
	exit 0
fi