#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init"

doc="$(cat <<'EOF'

# openai

OpenAI API client

`chat`						| Send a message to an AI model
`assistants.create`			| Create a new assistant
`threads.create`			| Create a new thread
`thread.messages.append`	| Append a message to a thread
`thread.messages.list`		| List messages in a thread
`thread.run`				| Run an assistant on a thread
`thread.run.poll`			| Poll the status of a thread run
`files.upload`				| Upload a file to the OpenAI API
`files.list`				| List files uploaded to the OpenAI API
`file.delete`				| Delete a file from the OpenAI API
`images.create`				| Generate images from a prompt
`audio.create`				| Generate audio from a text prompt
`audio.transcribe`			| Transcribe an audio file"

> openai chat "What is the capital of France?"									| Send a message to an AI model
> openai assistants.create -n "My Assistant" -i "This is a helpful assistant"	| Create a new assistant
> openai threads.create -m "Hello, world!"										| Create a new thread
> openai thread.messages.append -t "thread_id" -m "Hello, world!"				| Append a message to a thread
> openai thread.messages.list -t "thread_id"									| List messages in a thread

EOF
)" && inspect "$1"


# Requirements
[ -z "$OPENAI_API_KEY" ] && b/error env_error "OPENAI_API_KEY environment variable is not set"


# Function to make a request to the OpenAI API
curlRequest() {
    local OPTIND opt url file purpose data

    curl_opts=(-H "Authorization: Bearer $OPENAI_API_KEY" -H "OpenAI-Beta: assistants=v1" --silent)

    while getopts "u:f:p:d:j" opt; do
        case $opt in
            u ) url="$OPTARG" ;;
            f ) file="$OPTARG" ;;
            p ) purpose="$OPTARG" ;;
            d ) data="$OPTARG" ;;
            j ) json=true ;;
            \? ) echo "Invalid option: -$OPTARG" >&2; return 1 ;;
        esac
    done

    [[ -n "$file" ]] && curl_opts+=(-F "file=@$file")
    [[ -n "$purpose" ]] && curl_opts+=(-F "purpose=$purpose")
    [[ -n "$data" ]] && curl_opts+=(-d "$data")
    [[ -n "$json" ]] && curl_opts+=(-H "Content-Type: application/json") || curl_opts+=(-H "Content-Type: multipart/form-data")
    
    response=$(curl "$url" "${curl_opts[@]}")

    echo "$response" | jq -r
}


# Set default values
api_url="https://api.openai.com/v1"
default_model="gpt-3.5-turbo-0125"
command="$1" && shift


# Parse command line options
case "$command" in



	# ========================================================
	chat ) doc="$(cat <<'EOF'
# chat

Send a message to an AI model

`-m`	| * The message to send
`-a`	|   The system prompt (assistant prompt)
`-o`	|   The model to use
`-j`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai chat "What is the capital of France?"											| Send a message to an AI model
> openai chat -m "What is the capital of France?" -a "You are a helpful AI assistant."	| Send a message to an AI model

EOF
		)" && inspect "$1"

		format="text"
		message="$1"
		assistant_prompt="${2:-You are a helpful AI assistant.}"
		model="$default_model"
		while getopts ":m:a:o:jV" opt; do
			case ${opt} in
				m ) message="$OPTARG" ;;
				a ) assistant_prompt="$OPTARG" ;;
				o ) model="$OPTARG" ;;
				j ) format="json_object" ;;
				V ) verbose=true ;;
				* ) echo "Invalid option: -$OPTARG" >&2; return 1 ;;
			esac
		done

		response=$(curlRequest -u "$api_url/chat/completions" -d "$(jq -n --arg assistant_prompt "${assistant_prompt}" --arg model "${model}" --arg content "$message" --arg format "${format}" '{
			model: $model,
			response_format: { "type": $format },
			messages: [
				{ role: "system", content: $assistant_prompt },
				{ role: "user", content: $content }
			]
		}')" -j)
		content=$(echo "$response" | jq -r '.choices[0].message.content')

		[[ $verbose ]] && echo "$response" | jq || echo "$content"
		;;



    # ========================================================
    assistants.create ) doc="$(cat <<'EOF'

# assistants.create

Create a new assistant

`-n`	| * The name of the assistant
`-i`	| * Instructions for the assistant
`-o`	|   The model to use
`-t`	|   The tools to enable (pipe separated)
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai assistants.create -n "My Assistant" -i "This is a helpful assistant"	| Create a new assistant

EOF
		)" && export doc && inspect "$1"

        tools=()
        model=$default_model

        while getopts "n:i:t:oJV" opt; do
            case ${opt} in
                n ) assistant_name="$OPTARG" ;;
                i ) instructions="$OPTARG" ;;
                t ) IFS='|' read -ra tools <<< "$OPTARG" ;;
                o ) model="$OPTARG" ;;
                J ) respond="as_json" ;;
                V ) verbose=true ;;
                \? ) echo "Invalid option: -$OPTARG" >&2; return 1 ;;
            esac
        done

        if [[ -z "${tools[*]}" ]]; then
            tools=("code_interpreter" "retrieval")
        fi

        payload=$(jq -n --arg name "$assistant_name" --arg instructions "$instructions" --arg model "$model" --argjson tools "$(printf '%s\n' "${tools[@]}" | jq -R . | jq -s 'map({type: .})')" '{
            instructions: $instructions,
            name: $name,
            model: $model,
            tools: $tools
        }')

        response=$(curlRequest -u "$api_url/assistants" -d "$payload" -j)

        if [[ "$verbose" == true ]]; then
            echo "$response" | jq -r
        elif [[ "$respond" == "as_json" ]]; then
            echo "$response" | jq -r '{assistant_id: .id, tools: [.tools[] | .type]}'
        else
            echo "$response" | jq -r .id
        fi
        ;;



    # ========================================================
    threads.create ) doc="$(cat <<'EOF'

# threads.create

Create a new thread

`-m`	| * The initial message to send
`-f`	|   The file IDs to attach (comma-separated list)
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai threads.create -m "Hello, world!"	| Create a new thread

EOF
		)" && export doc && inspect "$1"

        file_ids=""

        while getopts ":m:f:JV" opt; do
            case ${opt} in
                m ) initial_message="$OPTARG" ;;
                f ) file_ids="$OPTARG" ;;
                J ) respond="as_json" ;;
                V ) verbose=true ;;
                \? ) b/error invalid_option "$OPTARG" && exit 1 ;;
            esac
        done

        # Convert the comma-separated list of file IDs into a JSON array
        file_ids_json=$(jq -nR '[inputs | split(",") | .[]]' <<< "$file_ids")

        payload=$(jq -n --arg initial_message "$initial_message" --argjson file_ids "$file_ids_json" '{
            messages: [ { role: "user", content: $initial_message, file_ids: $file_ids } ]
        }')

        response=$(curlRequest -u "$api_url/threads" -d "$payload" -j)

        if [[ "$verbose" == true ]]; then
            echo "$response" | jq -r
        elif [[ "$respond" == "as_json" ]]; then
            echo "$response" | jq -r '{thread_id: .id}'
        else
            echo "$response" | jq -r .id
        fi
        ;;



    # ========================================================
    thread.messages.append) doc="$(cat <<'EOF'

# thread.messages.append

Append a message to a thread

`-t`	| * The thread ID
`-m`	| * The message to send
`-f`	|   The file IDs to attach (array)
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai thread.messages.append -t "thread_id" -m "Hello, world!"	| Append a message to a thread

EOF
		)" && export doc && inspect "$1"

		file_ids="[]"

		while getopts ":t:m:f:JV" opt; do
			case ${opt} in
				t ) thread_id="$OPTARG" ;;
				m ) message="$OPTARG" ;;
				f ) file_ids="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		payload=$(jq -n --arg role "user" --arg content "$message" --argjson file_ids "$file_ids" '{
			role: $role,
			content: $content,
			file_ids: $file_ids
		}')

		response=$(curlRequest -u "$api_url/threads/$thread_id/messages" -d "$payload" -j)

		if [[ "$verbose" == true ]]; then
			echo "$response" | jq -r
		elif [[ "$respond" == "as_json" ]]; then
			echo "$response" | jq -r '{thread_id: .thread_id, message_id: .id}'
		else
			exit 0
		fi
		;;



    # ========================================================
    thread.messages.list ) doc="$(cat <<'EOF'

# thread.messages.list

List messages in a thread

`-t`	| * The thread ID
`-l`	|   The number of messages to return (default: 5)
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai thread.messages.list -t "thread_id"	| List messages in a thread

EOF
		)" && export doc && inspect "$1"

        limit=5
        
        while getopts ":t:l:JV" opt; do
            case ${opt} in
                t ) thread_id="$OPTARG" ;;
                l ) limit="${OPTARG:-5}" ;;
                J ) respond="as_json" ;;
                V ) verbose=true ;;
                \? ) b/error invalid_option "$OPTARG" ;;
            esac
        done

        [[ ! $limit =~ ^[0-9]+$ ]] && printf "ðŸš¨ 2:limit must be an integer\n" && exit 1

        response=$(curlRequest -u "$api_url/threads/$thread_id/messages?limit=$limit")

        # [[ "$verbose" == true ]] && echo "$response" | jq -r || echo "$response" | jq -r '{thread_id: .data[0].thread_id, messages: [.data[] | {role: .role, value: .content[0].text.value, created_at: .created_at}]}'
        if [[ "$verbose" == true ]]; then
            echo "$response" | jq -r
        elif [[ "$respond" == "as_json" ]]; then
            echo "$response" | jq -r '{thread_id: .data[0].thread_id, messages: [.data[] | {role: .role, value: .content[0].text.value, created_at: .created_at}]}'
        else
            echo "$response" | jq -r '.data[] | "\(.role): \(.content[0].text.value) | "' | sed 's/ | $//'
        fi
        ;;



    # ========================================================
    thread.run) doc="$(cat <<'EOF'

# thread.run

Run an assistant on a thread

`-t`	| * The thread ID
`-a`	| * The assistant ID
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai thread.run -t "thread_id" -a "assistant_id"	| Run an assistant on a thread

EOF
		)" && export doc && inspect "$1"

		while getopts ":t:a:JV" opt; do
			case ${opt} in
				t ) thread_id="$OPTARG" ;;
				a ) assistant_id="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		payload=$(jq -n --arg assistant_id "$assistant_id" '{
			assistant_id: $assistant_id
		}')

		response=$(curlRequest -u "$api_url/threads/$thread_id/runs" -d "$payload" -j)

		# [[ "$verbose" == true ]] && echo "$response" | jq -r || echo "$response" | jq -r '{thread_id: .thread_id, run_id: .id, status: .status}'
		if [[ "$verbose" == true ]]; then
			echo "$response" | jq -r
		elif [[ "$respond" == "as_json" ]]; then
			echo "$response" | jq -r '{thread_id: .thread_id, run_id: .id, status: .status}'
		else
			echo "$response" | jq -r '.id'
		fi
		;;



    # ========================================================
    thread.run.poll ) doc="$(cat <<'EOF'

# thread.run.poll

Poll the status of a thread run

`-t`	| * The thread ID
`-r`	| * The run ID
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai thread.run.poll -t "thread_id" -r "run_id"	| Poll the status of a thread run

EOF
		)" && export doc && inspect "$1"

        while getopts ":t:r:JV" opt; do
            case ${opt} in
                t ) thread_id="$OPTARG" ;;
                r ) run_id="$OPTARG" ;;
                J ) respond="as_json" ;;
                V ) verbose=true ;;
                \? ) b/error invalid_option "$OPTARG" && exit 1 ;;
            esac
        done

        response=$(curlRequest -u "$api_url/threads/$thread_id/runs/$run_id")

        # [[ "$verbose" == true ]] && echo "$response" | jq -r || echo "$response" | jq -r '{thread_id: .thread_id, run_id: .id, status: .status}'
        if [[ "$verbose" == true ]]; then
            echo "$response" | jq -r
        elif [[ "$respond" == "as_json" ]]; then
            echo "$response" | jq -r '{thread_id: .thread_id, run_id: .id, status: .status}'
        else
            echo "$response" | jq -r '.status'
        fi
        ;;



    # ========================================================
    files.upload ) doc="$(cat <<'EOF'

# files.upload

Upload a file to the OpenAI API

`-f`	| * The file to upload
`-p`	|   The purpose of the file (assistants)
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai files.upload -f "path/to/file"	| Upload a file to the OpenAI API

EOF
		)" && export doc && inspect "$1"

        purpose="assistants"
        while getopts ":f:p:JV" opt; do
            case ${opt} in
                f ) file="$OPTARG" ;;
                p ) purpose="$OPTARG" ;;
                J ) respond="as_json" ;;
                V ) verbose=true ;;
                \? ) b/error invalid_option "$OPTARG" && exit 1 ;;
            esac
        done

        response=$(curlRequest -u "$api_url/files" -f "$file" -p "$purpose")

        if [[ "$verbose" == true ]]; then
            echo "$response" | jq -r
        elif [[ "$respond" == "as_json" ]]; then
            echo "$response" | jq -r '{file_id: .id}'
        else
            echo "$response" | jq -r .id
        fi
        ;;


    # ========================================================
    files.list ) doc="$(cat <<'EOF'

# files.list

List files uploaded to the OpenAI API

`-p`	|   The purpose of the file (assistants)
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai files.list	| List files uploaded to the OpenAI API

EOF
		)" && export doc && inspect "$1"

		purpose="assistants"
		while getopts ":p:JV" opt; do
			case ${opt} in
				p ) purpose="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		url="$api_url/files?purpose=$purpose"

		response=$(curlRequest -u "$url")

		if [[ "$verbose" == true ]]; then
			echo "$response" | jq -r
		elif [[ "$respond" == "as_json" ]]; then
			echo "$response" | jq -r '[.data[] | {id: .id, purpose: .purpose, created_at: .created_at}]'
		else
			echo "$response" | jq -r '.data[] | .id'
		fi
		;;


    # ========================================================
    file.show ) doc="$(cat <<'EOF'

# file.show

Show details of a file uploaded to the OpenAI API

`-f`	| * The file ID
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai file.show -f "file_id"	| Show details of a file uploaded to the OpenAI API

EOF
		)" && export doc && inspect "$1"
    
		while getopts ":f:JV" opt; do
			case ${opt} in
				f ) file_id="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		response=$(curlRequest -u "$api_url/files/$file_id")

		# [[ "$verbose" == true ]] && echo "$response" | jq -r || echo "$response" | jq -r '{file_id: .id, status: .status, created_at: .created_at}'
		if [[ "$verbose" == true ]]; then
			echo "$response" | jq -r
		elif [[ "$respond" == "as_json" ]]; then
			echo "$response" | jq -r '{file_id: .id, status: .status, created_at: .created_at}'
		else
			echo "$response" | jq -r '.status'
		fi
		;;


    # ========================================================
    file.delete ) doc="$(cat <<'EOF'

# file.delete

Delete a file from the OpenAI API

`-f`	| * The file ID
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai file.delete -f "file_id"	| Delete a file from the OpenAI API

EOF
		)" && export doc && inspect "$1"
    
		while getopts ":f:JV" opt; do
			case ${opt} in
				f ) file_id="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		response=$(curl -X DELETE -H "Authorization: Bearer $OPENAI_API_KEY" --silent "$api_url/files/$file_id")

		if [[ "$verbose" == true ]]; then
			echo "$response" | jq -r
		elif [[ "$respond" == "as_json" ]]; then
			echo "$response" | jq -r '{file_id: .id, deleted: .deleted}'
		else
			exit 0
		fi
		;;


    # ========================================================
    images.create ) doc="$(cat <<'EOF'

# images.create

Generate images from a prompt

`-p`	| * The prompt to generate images from
`-m`	|   The model to use
`-n`	|   The number of images to generate
`-q`	|   The quality of the images
`-r`	|   The response format
`-s`	|   The size of the images
`-t`	|   The style of the images
`-u`	|   A unique identifier representing your end-user
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai images.create -p "A painting of a sunset over the ocean"	| Generate images from a prompt

EOF
		)" && export doc && inspect "$1"
    
		model="dall-e-3"
		n=1
		quality="standard"
		response_format="url"
		size="1024x1024"
		style="vivid"

		while getopts ":p:m:n:q:r:s:t:u:JV" opt; do
			case ${opt} in
				p ) prompt="$OPTARG" ;;
				m ) model="$OPTARG" ;;
				n ) n="$OPTARG" ;;
				q ) quality="$OPTARG" ;;
				r ) response_format="$OPTARG" ;;
				s ) size="$OPTARG" ;;
				t ) style="$OPTARG" ;;
				u ) user="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		payload=$(jq -n --arg model "$model" --arg prompt "$prompt" --argjson n "$n" --arg quality "$quality" --arg response_format "$response_format" --arg size "$size" --arg style "$style" --arg user "$user" '{
			model: $model,
			prompt: $prompt,
			n: $n,
			quality: $quality,
			response_format: $response_format,
			size: $size,
			style: $style,
			user: $user
		}')

		response=$(curlRequest -u "$api_url/images/generations" -d "$payload" -j)

		# [[ "$verbose" == true ]] && echo "$response" | jq -r || echo "$response" | jq -r '{images: [.data[].url]}'

		if [[ "$verbose" == true ]]; then
			echo "$response" | jq -r
		elif [[ "$respond" == "as_json" ]]; then
			echo "$response" | jq -r '{images: [.data[].url]}'
		else
			echo "$response" | jq -r '.data[].url'
		fi
		;;

        
    # ========================================================
    audio.create ) doc="$(cat <<'EOF'

# audio.create

Generate audio from a text prompt

`-i`	| * The input text
`-m`	|   The model to use
`-v`	|   The voice to use
`-r`	|   The response format
`-s`	|   The speed of the audio
`-u`	|   A unique identifier representing your end-user
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai audio.create -i "Hello, world!"	| Generate audio from a text prompt

EOF
		)" && export doc && inspect "$1"
    
		model="tts-1"
		voice="alloy"
		response_format="mp3"
		speed=1.0

		while getopts ":i:m:v:r:s:u:JV" opt; do
			case ${opt} in
				i ) input="$OPTARG" ;;
				m ) model="$OPTARG" ;;
				v ) voice="$OPTARG" ;;
				r ) response_format="$OPTARG" ;;
				s ) speed="$OPTARG" ;;
				u ) user="$OPTARG" ;;
				J ) respond="as_json" ;;
				V ) verbose=true ;;
				\? ) b/error invalid_option "$OPTARG" && exit 1 ;;
			esac
		done

		payload=$(jq -n --arg model "$model" --arg input "$input" --arg voice "$voice" --arg response_format "$response_format" --arg speed "$speed" --arg user "$user" '{
			model: $model,
			input: $input,
			voice: $voice,
			response_format: $response_format,
			speed: $speed,
			user: $user
		}')

		random_file_name=$(openssl rand -hex 16)

		curl https://api.openai.com/v1/audio/speech \
			-H "Authorization: Bearer $OPENAI_API_KEY" \
			-H "Content-Type: application/json" \
			-d "$payload" \
			--silent \
			--output ./tmp/$random_file_name.mp3

		if [[ "$verbose" == true ]]; then
			echo "{ \"file_path\": \"./$random_file_name.mp3\" }"
		elif [[ "$respond" == "as_json" ]]; then
			echo "{ \"file_path\": \"./$random_file_name.mp3\" }"
		else
			echo "./tmp/$random_file_name.mp3"
		fi
		;;


    # ========================================================
    audio.transcribe ) doc="$(cat <<'EOF'

# audio.transcribe

Transcribe an audio file

`-f`	| * The audio file to transcribe
`-o`	|   The output file
`-m`	|   The model to use
`-l`	|   The language of the audio
`-p`	|   The prompt to use
`-r`	|   The response format
`-t`	|   The temperature of the transcription
`-g`	|   The timestamp granularities
`-J`	|   Requests OpenAIs response be JSON
`-V`	|   Return the vendor response, verbosely

> openai audio.transcribe -f "path/to/audio"	| Transcribe an audio file

EOF
		)" && export doc && inspect "$1"

        language="en"
        output_file="$BARE_DIR/tmp/transcription-$(date +%Y%m%d-%H%M%S).txt"
        response_format="json"
        temperature=0
        timestamp_granularities="segment"
        model="whisper-1"

        while getopts ":f:o:m:l:p:r:t:g:JV" opt; do
            case ${opt} in
                f ) file="$BARE_DIR/$OPTARG" ;;
                o ) output_file="$OPTARG" ;;
                m ) model="$OPTARG" ;;
                l ) language="$OPTARG" ;;
                p ) prompt="$OPTARG" ;;
                r ) response_format="$OPTARG" ;;
                t ) temperature="$OPTARG" ;;
                g ) timestamp_granularities="$OPTARG" ;;
                J ) respond="as_json" ;;
                V ) verbose=true ;;
                \? ) b/error invalid_option "$OPTARG" && exit 1 ;;
            esac
        done

        # Define constants
        MAX_SIZE=5000000

        # Get file size
        file_size=$(wc -c <"$file")

        # If file size is greater than max size, split the file
        if (( file_size > MAX_SIZE )); then

            # First, check if ffmpeg is installed (we need it to split the file)
            [ ! -x "$(command -v ffmpeg)" ] && b/error "ffmpeg is not installed" "Please install ffmpeg to use this feature" && exit 1

            # Second, we don't weant to clog up the console with a huge response, so we need to specify an output file
            if [[ -z "$output_file" ]]; then
                echo "Error: File size exceeds limit for non-verbose mode. Please specify an output file."
                exit 1
            fi

            random_dir_name=$(openssl rand -hex 16)
            tmp_dir=$(mkdir -p ./tmp/"$random_dir_name" && echo ./tmp/"$random_dir_name")

            # Split the file into chunks and put them in the random directory
            ffmpeg -i "$file" -f segment -segment_time 300 -c copy -map 0 -segment_format mp3 -segment_list "$tmp_dir/files.txt" "$tmp_dir/chunk%03d.mp3" > /dev/null 2>&1

            # Initialize response array
            response_array="["

            # Process each chunk
            while IFS= read -r chunk; do
                chunk_path="$tmp_dir/$chunk"
                # Send request to API
                response=$(curl -X POST -H "Authorization: Bearer $OPENAI_API_KEY" -H "Content-Type: multipart/form-data" -F "file=@$chunk_path" -F "model=$model" -F "language=$language" -F "prompt=$prompt" -F "response_format=$response_format" -F "temperature=$temperature" -F "timestamp_granularities[]=$timestamp_granularities" -F "model=$model" --silent --max-time 60 https://api.openai.com/v1/audio/transcriptions)

                # Check if response is a valid JSON and contains 'text' field
                if echo "$response" | jq -e . >/dev/null 2>&1 && echo "$response" | jq 'has("text")' | grep -q true; then
                    # If verbose mode, store entire response, else extract text
                    if [[ "$verbose" = true ]]; then
                        # Limit the length of the 'segments.text' property to 140 characters
                        response=$(echo "$response" | jq '.segments[].text = (.segments[].text | .[0:140] + "...")')
                        response_array+="$response,"
                    else
                        echo "$response" | jq -r '.text' >> "$output_file"
                    fi
                else
                    echo "Error: Invalid response from API"
                    exit 1
                fi

                # Delete chunk
                rm "$chunk_path"
            done < "$tmp_dir/files.txt"

            # remove the tmp directory
            rm -r "$tmp_dir"

            # If verbose mode, print the response array
            if [[ "$verbose" = true ]]; then
                # Remove trailing comma and close array
                response_array=${response_array%?}
                response_array+="]"
                echo "$response_array"
            else
                jq -n --arg file "$output_file" '{file: $file}'
            fi
        else
            # Send the request to the API
            # Send the request to the API
            response=$(curl -X POST -H "Authorization: Bearer $OPENAI_API_KEY" -H "Content-Type: multipart/form-data" -F "file=@$file" -F "model=$model" -F "language=$language" -F "prompt=$prompt" -F "response_format=$response_format" -F "temperature=$temperature" -F "timestamp_granularities[]=$timestamp_granularities" --silent --max-time 60 https://api.openai.com/v1/audio/transcriptions)

            # Check if the response is valid JSON and contains 'text' field
            if echo "$response" | jq -e . >/dev/null 2>&1 && echo "$response" | jq 'has("text")' | grep -q true; then
                # If verbose mode, store entire response, else extract text
                if [[ "$verbose" = true ]]; then
                    echo "$response" | jq -r >> "$output_file"
                else
                    echo "$response" | jq -r '.text' >> "$output_file"
                fi
            else
                echo "Error: Invalid response from API"
                echo "Response: $response"
                exit 1
            fi
        fi

        # Get the relative path of the output file
        # [[ "$verbose" == true ]] && echo "$response" | jq -r || echo "{ \"file\": \"$(basename "$output_file")\" }"
        
        if [[ "$verbose" == true ]]; then
            echo "$response" | jq -r
        elif [[ "$respond" == "as_json" ]]; then
            jq -n --arg file "$output_file" '{file: $file}'
        else
            jq -rn --arg file "$output_file" '$file'
        fi


esac