#!/usr/bin/env bash

if [[ -t 0 ]]; then
    type=$1
    input=$2
    shift 2
else
    input=$(cat)
    type=$1
    shift
fi

output="false"

# Output approach: store output, then check if output exists

case $type in

	ai)

		runs_remaining=3
		condition="$input"
		source_material="$1" && shift
		model=${OPENAI_DEFAULT_MODEL:-'gpt-4o-mini'}

		while true; do
			case $1 in
				--explain) explain=true && shift ;;
				--high-powered) model='gpt-4o' && shift ;;
				--model) model="$2" && shift 2 ;;
				''|*) break ;;
			esac
		done
		
		while [ $runs_remaining -gt 0 ]; do
			response="$(openai chat "You are an expert validator. I will provide a condition and a source material. Your task is to determine if the source material satisfies the condition. Respond with one JSON object containing two properties: 'reasoning <string>' and 'answer <true/false boolean>' where 'reasoning' contains your reasoning and 'answer' is either true or false, indicating whether the source material satisfies the condition. - - - ###--### - - - CONDITION: $condition - - - SOURCE MATERIAL: $source_material - - - ###--### - - - So... what do you say? True or false; does the source material satisfy the condition? Remember, respond only with a one dimensional JSON object (containing just the 'reasoning' and 'answer' properties)." --model "$model" --json)"
		
			# Validate that response JSON object contains just two properties (reasoning and answer) and that answer is true or false boolean.
			if [[ $(echo "$response" | jq 'keys | length') -eq 2 && ( $(echo "$response" | jq -r '.answer') == 'true' || $(echo "$response" | jq -r '.answer') == 'false' ) ]]; then
				runs_remaining=0  # Valid response, exit the loop
			else
				runs_remaining=$((runs_remaining - 1))  # Invalid response, decrement runs_remaining
				if [ $runs_remaining -eq 0 ]; then
					echo "Sorry, we're having a hard time responding to this request. Maybe try rephrasing." && exit 1
				fi
			fi
		done

		[[ -n $explain ]] && echo "$response" | jq -r '.reasoning' && exit 0
		echo "$response" | jq -r '.answer' && exit 0 ;;


	alpha|alphabetic)
		if echo "$input" | grep -Eq '^[a-zA-Z]+$'; then
			output="true"
		fi
		;;

	alpha-underscore|alphabetic-underscore)
		if echo "$input" | grep -Eq '^[a-zA-Z_]+$'; then
			output="true"
		fi
		;;

	alpha-hyphen|alphabetic-hyphen)
		if echo "$input" | grep -Eq '^[a-zA-Z-]+$'; then
			output="true"
		fi
		;;

	alphanumeric)
		if echo "$input" | grep -Eq '^[a-zA-Z0-9]+$'; then
			output="true"
		fi
		;;

	uppercase|uppercased)
		if echo "$input" | grep -Eq '^[A-Z]+$'; then
			output="true"
		fi
		;;

	lowercase|lowercased)
		if echo "$input" | grep -Eq '^[a-z]+$'; then
			output="true"
		fi
		;;

	url|web-address|link)
		if echo "$input" | grep -Eq '^(https?:\/\/)?([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(\/.*)?$'; then
			output="true"
		fi
		;;

	ip)
		if echo "$input" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; then
			output="true"
		fi
		;;

	number|numeric|num)
		if echo "$input" | grep -Eq '^-?[0-9]+(\.[0-9]+)?$'; then
			output="true"
		fi
		;;

	integer|int|digit)
		if echo "$input" | grep -Eq '^-?[0-9]+$'; then
			output="true"
		fi
		;;

	email|email-address)
		if echo "$input" | grep -Eq '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; then
			output="true"
		fi
		;;

	uuid)
		if echo "$input" | grep -Eq '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'; then
			output="true"
		fi
		;;

	decimal|float|floating-point)
		precision=""
		digits=""
		while true; do
			case $1 in
				--places|--decimals|--precision) precision="$2" && shift 2 ;;
				--digits|--length) digits="$2" && shift 2 ;;
				'') break ;;
				*) shift ;;
			esac
		done

		regex="^[0-9]+(\.[0-9]{${precision:-1},})?$"
		if [[ -n $digits ]]; then
			regex="^[0-9]{${digits}}(\.[0-9]{${precision:-1},})?$"
		fi

		if echo "$input" | grep -Eq "$regex"; then
			output="true"
		fi

		;;

	date)
	
		date_format="%Y-%m-%d"
		
		# Parse the format argument
		case $1 in
			--format)
				case $2 in
					"mm-dd-yyyy") date_format="%m-%d-%Y" ;;
					"mm/dd/yyyy") date_format="%m/%d/%Y" ;;
					"mm.dd.yyyy") date_format="%m.%d.%Y" ;;
					"dd-mm-yyyy") date_format="%d-%m-%Y" ;;
					"dd/mm/yyyy") date_format="%d/%m/%Y" ;;
					"dd.mm.yyyy") date_format="%d.%m.%Y" ;;
					"yyyy-mm-dd") date_format="%Y-%m-%d" ;;
					"yyyy/mm/dd") date_format="%Y/%m/%d" ;;
					"yyyy.mm.dd") date_format="%Y.%m.%d" ;;
					"yyyy-mm-ddThh:mm:ss") date_format="%Y-%m-%dT%H:%M:%S" ;;
					"yyyy-mm-ddThh:mm:ssZ") date_format="%Y-%m-%dT%H:%M:%SZ" ;;
					"mm-dd-yyyy hh:mm:ss") date_format="%m-%d-%Y %H:%M:%S" ;;
					"mm/dd/yyyy hh:mm:ss") date_format="%m/%d/%Y %H:%M:%S" ;;
					"dd-mm-yyyy hh:mm:ss") date_format="%d-%m-%Y %H:%M:%S" ;;
					"dd/mm/yyyy hh:mm:ss") date_format="%d/%m/%Y %H:%M:%S" ;;
					*) date_format="$2" ;; # Default to the provided format
				esac
				shift 2
				;;
		esac
		
		# Detect the operating system
		os_type=$(uname)
		
		# Initialize output to false
		output="false"
		
		# Attempt to parse the date based on the OS
		if [ "$os_type" = "Darwin" ]; then
			# macOS
			if date -j -f "$date_format" "$input" >/dev/null 2>&1; then
				output="true"
			fi
		else
			# Assume Ubuntu or other Linux
			if date -d "$input" +"$date_format" >/dev/null 2>&1; then
				output="true"
			fi
		fi

		;;

	time)

		time_format="%H:%M"  # Default time format
			
		# Parse the format argument
		case $1 in
			--format)
				case $2 in
					"24-hour") time_format="%H:%M" ;; # e.g., 13:45
					"24-hour-seconds") time_format="%H:%M:%S" ;; # e.g., 13:45:30
					"12-hour") time_format="%I:%M %p" ;; # e.g., 01:45 PM
					"12-hour-seconds") time_format="%I:%M:%S %p" ;; # e.g., 01:45:30 PM
					*) time_format="$2" ;; # Use provided format
				esac
				shift 2
				;;
		esac
			
		# Normalize the input to handle lowercase am/pm
		normalized_input=$(echo "$input" | tr '[:lower:]' '[:upper:]')
			
		# Detect the operating system
		os_type=$(uname)
			
		# Initialize output to false
		output="false"
			
		# Attempt to parse the time based on the OS
		if [ "$os_type" = "Darwin" ]; then
			# macOS (BSD)
			if formatted_time=$(date -j -f "$time_format" "$normalized_input" +"$time_format" 2>/dev/null); then
				if [ "$formatted_time" = "$normalized_input" ]; then
					output="true"
				fi
			fi
		else
			# Assume Unix (Linux)
			if formatted_time=$(date -d "$normalized_input" +"$time_format" 2>/dev/null); then
				# Convert the formatted time back to the original format to ensure correctness
				if [[ "$(date -d "$formatted_time" +"$time_format")" == "$normalized_input" ]]; then
					output="true"
				fi
			fi
		fi
		;;

	true-false|true/false)

		if [[ $input == "true" || $input == "false" ]]; then
			output="true"
		fi
		;;

	yes-no|yes/no)

		if [[ $input == "yes" || $input == "no" ]]; then
			output="true"
		fi
		;;

	0-1|0/1)

		if [[ $input == "0" || $input == "1" ]]; then
			output="true"
		fi
		;;

	boolean)

		if [[ $input == "true" || $input == "false" || $input == "yes" || $input == "no" || $input == "y" || $input == "n" || $input == "0" || $input == "1" ]]; then
			output="true"
		fi

		;;

	phone|phone-number)

		country="US"

		while true; do
			case $1 in
				--country) country="$2" && shift 2 ;;
				'') break ;;
				*) shift ;;
			esac
		done

		case $country in
			US) if echo "$input" | grep -Eq '^\+?1?[ -]?\(?\d{3}\)?[ -]?\d{3}[ -]?\d{4}$'; then output="true"; fi ;;
			CA) if echo "$input" | grep -Eq '^\+?1?[ -]?\(?\d{3}\)?[ -]?\d{3}[ -]?\d{4}$'; then output="true"; fi ;;
			*) echo "Unsupported country code: $country" && exit 1 ;;
		esac
		
		;;


	zip|zip-code|postal-code)

		country="US"  # Default country
		while true; do
			case $1 in
				--country) country="$2" && shift 2 ;;
				'') break ;;
				*) shift ;;
			esac
		done

		case $country in
			US) if echo "$input" | grep -Eq '^[0-9]{5}(-[0-9]{4})?$'; then output="true"; fi ;;
			CA) if echo "$input" | grep -Eq '^[A-Za-z]\d[A-Za-z] \d[A-Za-z]\d$'; then output="true"; fi ;;
			GB) if echo "$input" | grep -Eq '^(GIR 0AA|[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][A-Z]{2})$'; then output="true"; fi ;;
			*) echo "Unsupported country code: $country" && exit 1 ;;
		esac
		;;



	*)
		echo "Invalid type: $type" && exit 1
		;;

esac

echo "$output"