#!/usr/bin/env bash

[[ -t 0 ]] && {
    type=$1 && input="$2" && shift 2
} || { input=$(cat); type=$1; shift; }

# Output approach: store output, then check if output exists

case $type in

	ai)

		runs_remaining=3
		condition="$input"
		source_material="$1" && shift
		model=${OPENAI_DEFAULT_MODEL:-'gpt-4o-mini'}

		while true; do
			case $1 in
				--explain) explain=true && shift ;;
				--high-powered) model='gpt-4o' && shift ;;
				--model) model="$2" && shift 2 ;;
				''|*) break ;;
			esac
		done
		
		while [ $runs_remaining -gt 0 ]; do
			response="$(openai chat "You are an expert validator. I will provide a condition and a source material. Your task is to determine if the source material satisfies the condition. Respond with one JSON object containing two properties: 'reasoning <string>' and 'answer <true/false boolean>' where 'reasoning' contains your reasoning and 'answer' is either true or false, indicating whether the source material satisfies the condition. - - - ###--### - - - CONDITION: $condition - - - SOURCE MATERIAL: $source_material - - - ###--### - - - So... what do you say? True or false; does the source material satisfy the condition? Remember, respond only with a one dimensional JSON object (containing just the 'reasoning' and 'answer' properties)." --model "$model" --json)"
		
			# Validate that response JSON object contains just two properties (reasoning and answer) and that answer is true or false boolean.
			if [[ $(echo "$response" | jq 'keys | length') -eq 2 && ( $(echo "$response" | jq -r '.answer') == 'true' || $(echo "$response" | jq -r '.answer') == 'false' ) ]]; then
				runs_remaining=0  # Valid response, exit the loop
			else
				runs_remaining=$((runs_remaining - 1))  # Invalid response, decrement runs_remaining
				if [ $runs_remaining -eq 0 ]; then
					echo "Sorry, we're having a hard time responding to this request. Maybe try rephrasing." && exit 1
				fi
			fi
		done

		[[ -n $explain ]] && echo "$response" | jq -r '.reasoning' && exit 0
		echo "$response" | jq -r '.answer' && exit 0 ;;


	alpha|alphabetic)

		output=$(echo "$input" | sed -E '/^[a-zA-Z]+$/!d') ;;

	alpha-underscore|alphabetic-underscore)

		output=$(echo "$input" | sed -E '/^[a-zA-Z_]+$/!d') ;;

	alpha-hyphen|alphabetic-hyphen)

		output=$(echo "$input" | sed -E '/^[a-zA-Z-]+$/!d') ;;

	alphanumeric)

		output=$(echo "$input" | sed -E '/^[a-zA-Z0-9]+$/!d') ;;

	uppercase|uppercased)

		output=$(echo "$input" | sed -E '/^[A-Z]+$/!d') ;;

	lowercase|lowercased)

		output=$(echo "$input" | sed -E '/^[a-z]+$/!d') ;;

    url|web-address|link)
        output=$(echo "$input" | sed -E '/^(https?:\/\/)?([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(\/.*)?$/!d') ;;

	ip)
		output=$(echo "$input" | sed -E '/^([0-9]{1,3}\.){3}[0-9]{1,3}$/!d') ;;

	number|numeric|num)

			[[ $(validate integer "$input") == 'true' || $(validate float "$input") == 'true' ]] && {
				output="$input"
			}

		;;

	integer|int|digit)

		# check for --digits --length of numeral count
		while true; do
			case $1 in
				'') break ;;
				--digits|--length) digits="$2" && shift 2 ;;
				*) shift ;;
			esac
		done

		[[ -n $digits && $(validate number "$digits") == false ]] && {
			echo "Error: integer digits argument not a number" && exit 1
		}

		# Default to any length if digits is not specified
		if [[ -z $digits ]]; then
			regex="^[0-9]+$"
		else
			regex="^[0-9]{${digits}}$"
		fi
		
		output=$(echo "$input" | sed -E "/$regex/!d")

		;;

	email|email-address)
		output=$(echo "$input" | sed -E '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/!d') ;;

	uuid)
		output=$(echo "$input" | sed -E '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/!d') ;;

	decimal|float|floating-point)
	
		while true; do
			case $1 in
				'') break ;;
				--places|--decimals|--precision) precision="$2" && shift 2 ;;
				--digits|--length) digits="$2" && shift 2 ;;
				*) shift ;;
			esac
		done
	
		# Validate that precision is a number
		[[ -n $precision && $(validate number "$precision") == 'false' ]] && {
			echo "Error: decimal precision argument not a number" && exit 1
		}
	
		# Validate that digits is a number
		[[ -n $digits && $(validate number "$digits") == 'false' ]] && {
			echo "Error: decimal digits argument not a number" && exit 1
		}
	
		# Construct regex based on the specified precision and digits
		if [[ -z $precision ]]; then
			regex="^[0-9]+(\.[0-9]+)?$"
		else
			regex="^[0-9]+(\.[0-9]{${precision}})?$"
		fi
	
		if [[ -n $digits ]]; then
			regex="^[0-9]{${digits}}(\.[0-9]{${precision}})?$"
		fi
	
		# Ensure the input must have decimal places
		regex="^[0-9]+(\.[0-9]{${precision:-1},})$"
	
		output=$(echo "$input" | sed -E "/$regex/!d")
	
		;;

    *)
        echo "Invalid type: $type" && exit 1
        ;;

esac

[[ -z $output ]] && echo "false" && exit 0

echo "true"