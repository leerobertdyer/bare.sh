#!/usr/bin/env bash

./deps jq xxd php awk perl

scope="$1" && shift

input="${1:-$(cat)}"

case $scope in

	text.filesafe ) echo -n "$input" | sed 's/ /-/g; s/[^a-zA-Z0-9._-]//g' ;;

	json.encode ) echo -n "$input" | jq -s -R -r @json ;;
	json.decode ) echo -n "$input" | jq -r . ;;

	# text.newlines ) echo -n "$input" | awk '{printf "%s  \\n", $0}' | tr -d '\n' ;;
	newlines.encode )
	  # Read input line by line, including the last line whether it ends with a newline or not
	  while IFS= read -r line || [[ -n "$line" ]]; do
		# Print the line with a \n at the end
		printf '%s\\n' "$line"
	  done <<< "$input"
	  echo ""
	;;
	newlines.decode ) echo -e "$input" ;;

	url.encode ) echo -n "$input" | jq -s -R -r @uri ;;
	url.decode ) echo -n "$input" | perl -pe 'chomp; s/%([0-9a-f]{2})/sprintf("%s", pack("H2",$1))/eig' && echo "" ;;

	form-data.encode )
		if [[ -n "$input" ]]; then
			encoded=$(echo "$input" | jq -r 'to_entries | map("\(.key)=\(.value|@uri)") | join("&")')
			echo "$encoded"
		else
			echo "No input provided."
		fi
		;;

	form-data.decode )
		declare -A params=()
		
		IFS='&' read -ra key_value_pairs <<< "$input"
		
		json_object="{"
		for key_value_pair in "${key_value_pairs[@]}"; do
			IFS='=' read -r key value <<< "$key_value_pair"
			
			# Decode the key and value from URL encoding
			decoded_key=$(echo -e $(sed 's/+/ /g;s/%\(..\)/\\x\1/g' <<< "$key"))
			decoded_value=$(echo -e $(sed 's/+/ /g;s/%\(..\)/\\x\1/g' <<< "$value"))
			
			# Ensure keys are URI encoded for JSON keys
			json_key=$(jq -Rr @uri <<<"$decoded_key")
			
			# Check if decoded_value is a JSON array or object
			if [[ $decoded_value == \{* ]] || [[ $decoded_value == \[* ]]; then
				# It's a JSON array or object, add it directly
				json_object+="\"$json_key\":$decoded_value,"
			else
				# It's a regular string, format it for JSON
				json_object+="\"$json_key\":$(jq -Rr @json <<<"$decoded_value"),"
			fi
		done
		json_object="${json_object%,}}"
		
		echo $json_object | jq -cM .
		;;

	base64.encode ) echo "$input" | jq -s -R -r @base64 ;;
	base64.decode ) echo "$input" | perl -MMIME::Base64 -ne 'print decode_base64($_)';;

	hex.encode ) echo "$input" | xxd -ps ;;
	hex.decode ) echo "$input" | xxd -r -p ;;

	html.encode )
		
		# Base64 encode the input to avoid issues with special characters
		encoded_input=$(echo "$input" | base64)
	
		# Decode from base64 and then encode to HTML
		echo "$encoded_input" | base64 --decode | jq -j -s -R -r @html
		;;
	html.decode ) echo "$input" | php -R 'echo html_entity_decode($argn, ENT_QUOTES|ENT_HTML5) . "\n";' ;;

	recfile.encode )
		# Read the input into an array
		IFS=$'\n' read -r -d '' -a lines <<< "$input"
		
		# Print the first line
		echo "${lines[0]}"
		
		# Print each subsequent line with a '+ ' prefix
		for ((i=1; i<${#lines[@]}; i++)); do
			echo "+ ${lines[$i]}"
		done
		;;


esac

exit 0