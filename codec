#!/usr/bin/env bash

./deps jq xxd php awk perl

scope="$1" && shift

# Initialize a variable to indicate whether input should be read from a file
read_from_file=false
input=""

# Check for the --file option
if [[ "$1" == "--file" ]]; then
    read_from_file=true
    shift # Remove --file from arguments
fi

# Read input based on the presence of the --file option
if $read_from_file; then
    # Ensure a filename is provided
    if [[ -z "$1" ]]; then
        echo "No file specified."
        exit 1
    fi
    # Read input from the specified file
    input="$(cat "$1")"
else
    # Check if data is being piped into stdin
    if [ -t 0 ]; then
        # No data piped in, use the first argument as input
        input="$1"
    else
        # Data is being piped in, read stdin into a variable
        input="$(cat)"
    fi
fi

case $scope in

	text.newlines ) echo "$input" | awk '{ printf "%s\\n", $0 }' ;;

	url.encode ) echo "$input" | jq -s -R -r @uri ;;
	url.decode ) echo "$input" | perl -pe 's/%([0-9a-f]{2})/sprintf("%s", pack("H2",$1))/eig' ;;

	form-url.encode )
		if [[ -n "$input" ]]; then
			# Convert JSON to form-url-encoded string
			encoded=$(echo "$input" | jq -r 'to_entries | map("\(.key)=\(.value|@uri)") | join("&")')
			echo "$encoded"
		else
			echo "No input provided."
		fi
		;;

	form-url.decode )
		decoded_data=$(printf '%b' "${input//%/\\x}")
		echo "$decoded_data" | jq .
		;;

	base64.encode ) echo "$input" | jq -s -R -r @base64 ;;
	base64.decode ) echo "$input" | perl -MMIME::Base64 -ne 'print decode_base64($_)' ;;

	hex.encode ) echo "$input" | xxd -ps ;;
	hex.decode ) echo "$input" | xxd -r -p ;;

	html.encode ) echo "$input" | jq -j -s -R -r @html ;;
	html.decode ) echo "$input" | php -R 'echo html_entity_decode($argn, ENT_QUOTES|ENT_HTML5) . "\n";' ;;

esac