#!/usr/bin/env bash

script_to_call="$1"
csv_file=".var/$2"

# Initialize lax_mode to 0 (false)
lax_mode=0

# Check for --lax flag in the remaining arguments
for arg in "$@"; do
	if [[ "$arg" == "--lax" ]]; then
		lax_mode=1
		break
	fi
done

if [ ! -f "$csv_file" ]; then
	echo "Error: $csv_file file not found"
	exit 1
fi

# Remove the first two arguments and any --lax flag
shift 2
args=("$@")
for i in "${!args[@]}"; do
	if [[ "${args[$i]}" == "--lax" ]]; then
		unset 'args[i]'
	fi
done

# Check if the last line of the CSV file is empty, and if not, add an empty line
if [ -n "$(tail -c 1 "$csv_file")" ]; then
	echo "" >> "$csv_file"
fi

# Function to clean and remove unnecessary quotes from values
clean_value() {
	local value="$1"
	# Remove surrounding quotes if they exist
	if [[ "$value" =~ ^\"(.*)\"$ ]]; then
		value="${BASH_REMATCH[1]}"
	fi
	# Replace escaped quotes with a single quote
	value="${value//\"\"/\"}"
	echo "$value"
}

# Read the header line and convert it into an array of column names
IFS=, read -r -a column_names < <(sed 's/"//g' "$csv_file")

# Process the file starting from the second line
tail -n +2 "$csv_file" | while IFS=, read -r -a line_values; do
	# Skip empty lines
	if [ -z "${line_values[0]}" ]; then
		continue
	fi

	# Dynamically create variables for each column
	for i in "${!column_names[@]}"; do
		value="${line_values[$i]}"
		clean_value=$(clean_value "$value")
		declare "${column_names[$i]}"="$clean_value"
	done

	# Prepare the arguments for the script based on the column names
	args=()
	for column in "${column_names[@]}"; do
		args+=("${!column}")
	done

	# Call the script with the dynamically determined arguments
	./bare interpret "$script_to_call" "${args[@]}"

	# If lax_mode is enabled, sleep for 0.2 seconds
	if [[ $lax_mode -eq 1 ]]; then
		sleep 0.2
	fi
done
